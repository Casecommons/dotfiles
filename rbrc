module Unbundler
  def self.require_external_gem gem
    if defined? Bundler
      unless Bundler.require.map(&:name).include? gem
        gems_dir = $LOAD_PATH.grep(%r{lib/ruby/gems/}).first.gsub(%r{(lib/ruby/gems/[^/]+)/.*$}, '\\1/gems')
        gem_path = Dir["#{gems_dir}/*"].to_a.detect do |gem_path|
          File.basename(gem_path).gsub(/-(\d\.?)+$/, '') == gem
        end

        if gem
          $LOAD_PATH << "#{gem_path}/lib"
          require gem
        else
          raise LoadError
        end
      end
    else
      require gem
    end
  end
end

def command_exists? command
  system "which #{command} > /dev/null 2> /dev/null"
end

def rbenv?; command_exists? 'rbenv'; end
def rvm?; command_exists? 'rvm'; end

def print_ruby_version
  Unbundler.require_external_gem 'paint'

  real_version = "#{RUBY_VERSION}-p#{RUBY_PATCHLEVEL}"

  manager, version = if rvm?
                       ['RVM', `rvm current`.split("\n").last]
                     elsif rbenv?
                       ['rbenv', `rbenv version`.strip]
                     else
                       [nil, real_version]
                     end

  if version =~ /system/
    system_raw_version = `$(whereis ruby) --version`
    system_major = system_raw_version.match(/ruby (\d\.\d\.\d)/).captures.first
    system_patch = system_raw_version.match(/patchlevel (\d+)/).captures.first
    version = version.sub(/system/, "system (#{system_major}-p#{system_patch})")
  end

  if version.match(/\d\.\d\.\d-p\d+/).to_s != real_version
    manager ||= 'built-in ruby'
    manager = "(#{manager} bypassed)"
    version = real_version
  end

  version_str = "#{manager} using #{version}"
  puts Paint[version_str, :bold, :underline]
end

def cli?
  is_pry_cli = defined?(Pry) && Pry.cli
  is_rails_console = defined?(Rails::Console)
  is_other_console = $PROGRAM_NAME =~ /console/
  is_irb = $PROGRAM_NAME == 'irb'

  is_pry_cli || is_rails_console || is_other_console || is_irb
end

print_ruby_version if cli?

class Array
  def self.toy n = 10
    Array.new(n) { |i| i }.shuffle
  end
end

class Hash
  def self.toy n = 5
    keys = ('a'..'z').to_a.take(n).shuffle
    values = Array.toy(n)
    Hash[keys.zip(values)]
  end
end

module Clipboard
  module Pasteboard
    def self.match?
      command_exists?('pbcopy') && command_exists?('pbpaste')
    end

    def copy object
      IO.popen('pbcopy', 'w') { |f| f << object.to_s }
      $?.exited?
    end

    def paste
      `pbpaste`
    end
  end

  module Xclip
    def self.match?
      command_exists? 'xclip'
    end

    def copy object
      IO.popen('xclip -selection clipboard', 'w') { |f| f << object.to_s }
      $?.exited?
    end

    def paste
      `xclip -selection clipboard -o`
    end
  end

  module Xsel
    def self.match?
      command_exists? 'xsel'
    end

    def copy object
      IO.popen('xsel --clipboard --input', 'w') { |f| f << object.to_s }
      $?.exited?
    end

    def paste
      `xsel --clipboard --output`
    end
  end

  STRATEGIES = [Pasteboard, Xclip, Xsel]

  def self.included klass
    return unless capable?
    klass.send :include, strategy
  end

  def self.capable?
    !!strategy
  end

  def self.strategy
    @strategy ||= STRATEGIES.detect(&:match?)
  end
end

singleton_class.send :include, Clipboard if Clipboard.capable?

# Load if in Rails console
if ($0 == 'irb' && ENV['RAILS_ENV']) || ($0 == 'script/rails' && Rails.env) || (defined?(Rails) && Rails.env)
  def change_log(stream)
    if defined? ActiveRecord::Base
      ActiveRecord::Base.logger = Logger.new stream
      ActiveRecord::Base.clear_active_connections!
    end
  end

  def show_log
    change_log STDOUT
  end

  def hide_log
    change_log nil
  end

  change_log STDOUT
end
